---
title: 'openvslam map-localization'
date: 2020-12-24
---

### OPENVSLAM Map-Localization

这篇blog主要想描述一下特征点法slam中基于prior feature-map进行localization的细节，这里以openvslam为例，和orbslam2中的流程基本一致，只是openvslam中提供了地图的dump, load, localizaton and slam等多种功能

#### Feature-Map Format
在运行openvslam slam模式的条件下，可以生成特征点地图，这也是后续用来定位的先验地图，这里对其地图内容做简要的描述：

存储的地图中包括了map_db, cam_db等信息，其map_database的数据结构，也就是ORBSLAM2中map的结构如下所示：

1. keyframes
2. landmarks
3. local landmarks
4. origin_keyframes (起始关键帧)

存下来的地图文件中包含的信息主要有关键帧信息，路标信息和它们的对应关系，将地图中的上述信息decode出来

* 构建关键帧

首先对关键帧进行解码，将地图中的关键帧信息解析到map_database中的keyframes里面，首先注入当前关键帧的meta data, 包括：

1. n_keypts keypoint的个数

2. ts 时间戳

3. cam 相机名称

4. depth_thr　深度阈值

然后注入当前关键帧的其他信息：

5. pose信息
6. 关键点信息(坐标，方向，层级)，
7. 关键点的描述子
8. x_right和depth

通过这些信息来构造关键帧，将其加入map_database中的keyframes中。

* 构建landmark

然后对路标点进行解码，将存储的路标信息解析到map_database中的landmarks里面，地图中的路标信息主要有:
1. 1st_keyfrm 第一个看到该路标点的关键帧
2. pow　三维位置
3. ref keyframe 该路标点的参考关键帧
4. n_vis 
5. n_fnd

* 构建spanning tree

然后根据存储的关键帧的链接关系构建spanning tree, 形成关键帧之间的connection graph,
解码的关键帧信息主要有:
1. span_parent 当前关键帧的父亲节点(唯一)
2. span_children 当前关键帧的孩子节点(可能有多个)
3. loop_edges  当前帧的回环帧
通过上述信息可以建立起当前关键帧的graph node(parent , children, loop edges)

* 建立关键帧和地图点的链接

然后建立解析出的关键帧和地图点互相之间的链接关系，解析的关键帧信息为lm_ids,标记了当前关键帧的特征点所对应的地图点在landmarks中的索引，然后就是两个链接关系：
```
keyfrm->add_landmark(lm, idx) \\设定关键帧的第idx个特征点所对应的路标
lm->add_observation(keyfrm, idx) \\设定那个路标点观测到了关键帧的第idx个特征点
```
* update covisibility graph

根据关键帧和地图点的对应关系，通过当前关键帧的地图点的观测信息来更新关键帧的共视关系，形成共视图

* update landmark geometry and desc

根据观测到路标点的多个关键帧更新路标点的法向，深度以及描述子

构建的特征点地图如图所示：
![](../images/openvslam_feature_map.png)

包括了路标点，关键帧, graph

####　Map-Based Relocalization

在有了先验地图的条件下，不需要像slam模式下的单目那样需要初始化，初始的时候跟踪器的状态为lost,然后在第一帧的时候进入重定位模式，利用当前帧和keyframe_database进行重定位，主要步骤包括：
1. 根据当前帧的词袋向量计算当前帧的候选关键帧
2. 对当前帧和候选关键帧逐一进行bow match
3. 根据特征点和对应的路标构建pnp-solver, EPNP-RANSAC计算当前相机的pose的初值
4. 根据pnp的inlier correspondence利用pose-optimizer对当前帧的pose进行优化
5. 利用优化后的pose进行投影匹配来获得更多的2d-3d的对应关系，重新用pose-optimizer 进行优化
6. 如果inlier大于阈值，则重定位成功，否则基于已经找到的路标，在进行一次投影匹配，尝试pose-optimize

可以看到其始终秉承这样一种pose求解的范式：先用代数算法解算一个初始的pose(用了最少的correspondence),然后利用更多的correspondence优化解算pose,再利用更准确的pose通过投影匹配得到更多的correspondence来进行优化求解。Pose的精度from coarse to fine, 所利用的数据量from less to more

如图显示了重定位成功的一帧:
![](../images/reloc_success.png)

如图显示了每一帧都做重定位的运行结果，基本上都可以进行稳定定位
![](../images/reloc.gif)

#### Map-Based Tracking
todo...